# 아키텍처 결정 기록 (ADR)

프로젝트의 핵심 아키텍처 결정 사항을 기록합니다.

## ADR-001: 왜 BFF 패턴인가?

**결정**: 모든 쓰기 작업은 BFF를 경유해야 함

**이유**: 
1. **보안**: 클라이언트에 `service_role` 키 노출 방지 (RLS 우회 권한)
2. **일관성**: 게임화 로직 중앙 집중 (포인트/배지/스트릭 계산)
3. **복잡성**: 트랜잭션 처리 (카드 완료 + 포인트 부여 + 배지 확인 + 감사 로그)
4. **검증**: 비즈니스 규칙 강제 (하루 1카드, 중복 체크 방지 등)

**대안 검토**: Direct Supabase 쓰기 → RLS만으로는 게임화 로직 불가능

**변경 비용**: 극히 높음 (전체 보안 모델 및 비즈니스 로직 재설계)

---

## ADR-002: 왜 3단계 A11y 모드인가?

**결정**: Normal/Easy/Ultra 고정 (슬라이더 방식 아님)

**이유**: 
1. **사용자 차이**: 50대(일반) vs 60대(쉬움) vs 70대(초대형)의 시력/손떨림 격차
2. **터치 영역**: 단순 폰트 크기 조절로는 버튼 터치 문제 해결 안 됨
3. **인지 부담**: 슬라이더는 오히려 시니어에게 복잡함 (선택 피로)
4. **테스트 결과**: 사용자 테스트에서 3단계가 최적으로 검증됨

**대안 검토**: 연속 슬라이더, 5단계 모드 → 인지 부담 증가

**변경 비용**: 중간 (UI 토큰 재설계, 컴포넌트 수정 필요)

---

## ADR-003: 왜 Envelope 패턴인가?

**결정**: 모든 API 응답은 `{ ok: boolean, data?: T, error?: E }` 형식

**이유**: 
1. **일관성**: 클라이언트가 단일 패턴으로 성공/실패 처리
2. **타입 안전**: TypeScript에서 discriminated union으로 타입 좁히기
3. **에러 상세**: HTTP 상태코드 외에 구조화된 에러 정보 제공
4. **한국어 메시지**: error.message에 시니어가 이해 가능한 한국어 포함

**대안 검토**: 표준 HTTP 상태코드만 사용 → 세밀한 에러 핸들링 어려움

**변경 비용**: 낮음 (초기 설계 단계에서 결정됨)
